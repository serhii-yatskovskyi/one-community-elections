step-1 и step-5 выглядят хорошо.

План такой:
1) Единый агрегат [step-1]
   - Один класс и вложенные в него сущности 
   - Репозиторий как точка доступа. Репозиторий - контейнер с коллекцией агрегат-рут. Пока метод get
     или list(filter) **(надо добавить в step-5)**, а потом остановимся подробнее, почему они не годятся.
   - Идентификаторы: задача не хранить значение, а идентифицировать, поэтому нет возврата сырого значения
2) Разбить по горизонтали (с ошибками компиляции) [step-2]
   - Разбить
   - Два репозитория. На каждый класс агрегат руут должен быть свой класс репозитория
3) Синхронизация через события [step-2]
   - Как связать low-coupling? Каждый разбитый становится Observer-ом. Добавим EntitySynchronization. Апп леер связывает
     классы домена между собой. Кубики. Оркестратор.
   - Как передать? Провайдер-интерфейс. Реализацию предоставит инфра. **Он может вытянуть репозиторий (делегат) и обернуть его в класс-сервис**
4) Разбивка по вертикали
   - Уже известные действия: "разбивуны" становятся обзервером, связываем через события, провайдер-интерфейс
   - Фэктори, точнее, креэйторы
5) Остановимся, сделаем ряд улучшений
   - Как сделать так, чтобы embedded non-static классы стали отдельными, но по-прежнему, non-static? Правильно! надо передать ссылку parent в конструктор.
   - Теперь, подключим библиотеку и пройдемся по некоторым пунктам, почему так и зачем библиотека.
   - Entity и Aggregate Root
   - Identifier
   - Declare
6) Events **(вот тут еще поразмыслить, как лучше: возврат или передача sync. Последнее луше показало себя в ElectionCreator, так как мы добавляем сущность как слушателя.)
   но в реальных проектах такого не будет. Надо подумать...)**
7) 