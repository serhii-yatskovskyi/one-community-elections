step-1 и step-5 выглядят хорошо.

План такой:
1) Единый агрегат [step-1]
   - Один класс и вложенные в него сущности 
   - Репозиторий как точка доступа. Репозиторий - контейнер с коллекцией агрегат-рут. Пока метод get
     или list(filter) **(надо добавить в step-5)**, а потом остановимся подробнее, почему они не годятся.
   - Идентификаторы: задача не хранить значение, а идентифицировать, поэтому нет возврата сырого значения
2) Разбить по горизонтали (с ошибками компиляции) [step-2]
   - Разбить
   - Два репозитория. На каждый класс агрегат руут должен быть свой класс репозитория
3) Синхронизация через события [step-2]
   - Как связать low-coupling? Каждый разбитый становится Observer-ом. Добавим EntitySynchronization. Апп леер связывает
     классы домена между собой. Кубики. Оркестратор.
   - Событие должно перенести все те вещи, которыми пользовалась вторая часть кода. Провайдеры - тоже. Это как разбить
     на две функции, и событие - это набор арг для второй. Это как команда для второго метода
   - Как передать? Провайдер-интерфейс. Реализацию предоставит инфра. **Он может вытянуть репозиторий (делегат) и обернуть его в класс-сервис**
4) Разбивка по вертикали
   - Уже известные действия: "разбивуны" становятся обзервером, связываем через события, провайдер-интерфейс
   - Фэктори, точнее, креэйторы
5) Остановимся, сделаем ряд улучшений
   - Как сделать так, чтобы embedded non-static классы стали отдельными, но по-прежнему, non-static? Правильно! надо передать ссылку parent в конструктор.
   - Теперь, подключим библиотеку и пройдемся по некоторым пунктам, почему так и зачем библиотека.
   - Entity и Aggregate Root
   - Identifier
   - Declare
6) Events **(вот тут еще поразмыслить, как лучше: возврат или передача sync. Последнее луше показало себя в ElectionCreator, так как мы добавляем сущность как слушателя.)
   но в реальных проектах такого не будет. Надо подумать...)**
   К слову, несмотря на то, что updateOn - public, его просто так не вызовешь, потому что Events имеют private-package конструктор.

# Добавляем внешний модуль
адм и онл-бэлл модули, оба имеют онлайн-голосование. Но они - разные в контекстах. Для юзера, онлайн голосование еще не началось, началось и т.п.
для адм. больше интересует сумма результатов, и он просто ждет, когда ему передадут. А когда именно, это - обязанность онл-бэлл модуля (он знает время завершения, которое не нужно для адм модуля)

А что если онл-бэлл потух и не прислал?
- Мы продолжаем ждать
- Но если не хотим ждать, то мы ждем таймаут и ставим дефолтные значения. В этом случае дата нужна в обоих модулях
Второй сценарий вряд ли подойдет заказчику в данном случае, но дабы вы понимали возможность, озвучиваем ее и ее детали.

Внешний модуль общается через АПИ

## АПИ

Обычно вспоминают про команды запросы. Но забывают про события. Но это - тоже часть АПИ
Раз часть, то должна выставляться в APP леере. Леер должен выставить метод "подписаться" или "вытянуть", в зависимости от
выбранной модели приема событий, пассивной или активной.
Это, обычно, pub-sub и event-queue.
Асинхронная read-модель
Приватные - для синхронизации, публичные - это часть API аппликейшна.
В АПИ есть,
- методы-команды (асинхронное АПИ, write)
- методы-запросы (асинхронное АПИ, read)
- канал, на который подписываемся (синхронное АПИ, read)

### Публичные события

Выброс из АПП леера. Откуда он знает, когда выбрасывать? инициация синхронизации и все ее выполнение - это один поток.

Команда возвращает
- результат или void + 200
- референс запроса и ссылка, где проверить (poll) или куда подписаться (pub-sub) + 201 (а если это - другой модуль?
  мы просто выбрасываем событие в воздух, а там, кто хочет, тот и слышит).
Далее, подписываемся или опрашиваем.
  Не все приватные должны быть опубликованы. В случае единого агрегата, 

# Появление транзакционности
Это надо, когда, пользователь не один
Псевдокодом это вот так было бы без базы данных
```
var clone = aggRoot.clone()
try {
    clone.doSomething();
} catch {
}
aggRoot.applyChanges(clone);
```
Синхронизация аггрРут, мы сказали, идет в одном потоке, однако, она может быть в одной транзакции, а может быть в изолированных.
**(Чтоб было в разных последовательных, а не в разных вложенных, надо события возвращать, а не запускать синхро внутри домена - вот почему возврат событий - лучше)**


ТО, ЧТО ТЕРЯЕТ ССЫЛКУ НА АГГРЕГАТ РУТ, ТЕПЕРЬ СВЗЫВАЕТСЯ ЧЕРЕЗ АПП ЛЕЕР
Репо - это контейнер коллекции, которая лежала внутри аггрут. Коллекция потеряла ссылку на аггРут. Значит, связь ушла, значит, связь устанавливается через апп леер.

Почему EventBus? Потому что вынуждена синхронизировать не только Entity, но и AppLayerEventHandler